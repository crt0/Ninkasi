#!/usr/bin/perl -T

use strict;
use warnings;

use lib '[% install_base %]/lib/perl5';

use File::Spec;
use Taint::Util;

BEGIN {
    if ( exists $ENV{NINKASI_TEST_SERVER_ROOT} ) {
        my $blib = File::Spec->catfile($ENV{NINKASI_TEST_SERVER_ROOT},
                                       File::Spec->updir(), 'blib');
        untaint $blib;
        require lib;
        lib->import( File::Spec->catfile($blib, 'lib' ),
                     File::Spec->catfile($blib, 'arch') );
    }
}

use CGI;
use Ninkasi::Assignment;
use Ninkasi::Category;
use Ninkasi::Config;
use Ninkasi::Constraint;
use Ninkasi::Judge;
use Ninkasi::JudgeSignup;
use Ninkasi::Template;
use URI::Escape ();

# fetch the list of category numbers a judge has been assigned for each flight
sub fetch_categories {
    my ($judge_id) = @_;

    # fetch categories this judge has been assigned
    my $category = Ninkasi::Category->new();
    my ($sth, $result) = $category->bind_hash( {
        bind_values => [$judge_id],
        columns     => [qw/number flight/],
        order       => 'number',
        where       => 'judge = ?',
    } );

    # walk the rows, building a list of category numbers for each flight
    my @flight = ();
    while ( $sth->fetch() ) {
        push @{ $flight[ $result->{flight} ] }, $result->{number};
    }

    return \@flight;
}

# generate a comma-separated list of hyperlinked constraints
sub fetch_constraint_lists {
    my ($judge_id, $suppress_hyperlinks) = @_;

    # fetch constraints for the specified judge
    my $constraint = Ninkasi::Constraint->new();
    my ($sth, $result) = $constraint->bind_hash( {
        bind_values => [$judge_id],
        columns     => [qw/category type/],
        order       => 'category',
        where       => 'judge = ?',
    } );

    # intialize a hash to store the constraint lists (indexed by type name)
    my %constraint = ();

    # build an index of missing rows (we'll remove the categories we find)
    my %not_found  = ();
    @not_found{ 1 .. $#Ninkasi::JudgeSignup::CATEGORIES } = ();

    # walk the rows, building constraint lists
    while ( $sth->fetch() ) {

        # add this category to the appropriate constraint list
        push @{ $constraint{ $Ninkasi::Constraint::NAME{ $result->{type} } } },
             $result->{category};

        # we found a constraint for this category, so delete it from %not_found
        delete $not_found{ $result->{category} };
    }

    # add any missing rows to the 'whatever' list
    @{ $constraint{whatever} }
        = sort { $a <=> $b } keys %not_found, @{ $constraint{whatever} || [] };

    # return a hash of comma-separated, hyperlinked constraint lists
    return {
        map {
            my @categories = @{ $constraint{$_} || [] };
            if (!$suppress_hyperlinks) {
                @categories
                    = map { qq{<a href="../assignment/$_">$_</a>} }
                          @categories;
            }

            $_ => join ', ', @categories;
        } keys %constraint
    };
}

# display big table of all judges
sub view_all_judges {
    my ($cgi_object, $format) = @_;

    # columns to display
    my @judge_columns = qw/rowid first_name last_name rank competitions_judged
                           pro_brewer/;

    # select whole table & order by last name
    my $judge = Ninkasi::Judge->new();
    my ($sth, $result) = $judge->bind_hash( {
        columns => \@judge_columns,
        order   => 'last_name',
    } );

    # initialize queue for updates we'll find when rendering page
    my @update_queue = ();

    # escape HTML but not for CSV output
    my $escape_html = sub { $format eq 'csv' ? sub { shift } : 'html_entity' };

    # process the template, passing it a function to fetch judge data
    my $template_object = Ninkasi::Template->new();
    $template_object->process( 'view_judges.tt', {
        cgi           => scalar $cgi_object->Vars(),
        escape_html   => $escape_html,
        escape_quotes => sub { \&escape_quotes },
        fetch_judge => sub {
            return $sth->fetch() && {
                %$result,
                fetch_assignments => sub {
                    Ninkasi::Assignment::fetch $result->{rowid};
                },
                fetch_categories => sub { fetch_categories $result->{rowid} },
                fetch_constraint_lists
                    => sub { fetch_constraint_lists $result->{rowid},
                                                    $format eq 'csv' },
            };
        },
        queue_update => sub { push @update_queue, [@_] },
        rank_name => \%Ninkasi::Judge::NAME,
        remove_trailing_comma => sub { \&remove_trailing_comma },
        title     => 'Registered Judges',
        type      => $format,
    } ) or warn $template_object->error();
    $sth->finish();

    # process queue of updates collected while rendering page
    my $category = Ninkasi::Category->new();
    my $table_name = $category->Table_Name();
    my $dbh = $category->Database_Handle();
    foreach my $update (@update_queue) {
        my ($judge_id, $flight_number, $category_numbers) = @$update;

        # remove old categories
        $dbh->do(<<EOF, {}, $judge_id, $flight_number);
DELETE FROM $table_name WHERE judge = ? AND flight = ?
EOF

        # insert new ones
        foreach my $category_number (split /[^\d]+/, $category_numbers) {
            $category->add( {
                flight => $flight_number,
                judge  => $judge_id,
                number => $category_number,
            } );
        }
    }

    return;
}

sub view_judge {
    my ($cgi_object, $format, $judge_id) = @_;

    # show all judges if no id is specified
    return view_all_judges $cgi_object, $format if !$judge_id;

    # columns to display
    my @judge_columns = qw/rowid first_name last_name address city state zip
                           phone_evening phone_day email rank bjcp_id
                           competitions_judged pro_brewer when_created/;

    # fetch the judge object from the database
    my $judge = Ninkasi::Judge->new();
    my ($sth, $result) = $judge->bind_hash( {
        bind_values => [$judge_id],
        columns     => \@judge_columns,
        where       => 'rowid = ?',
    } );
    $sth->fetch();

    # process the template to display this judge's information
    my $template_object = Ninkasi::Template->new();
    $template_object->process( 'view_judge.html', {
        judge     => $result,
        rank_name => \%Ninkasi::Judge::NAME,
        title     => join( ' ', @$result{qw/first_name last_name/} ),
    } ) or warn $template_object->error();

    # ignore remaining rows
    $sth->finish();

    return;
}

sub escape_quotes {
    my ($text) = @_;
    $text =~ s/"/""/g;
    return $text;
}

sub remove_trailing_comma {
    my ($text) = @_;
    $text =~ s/,$//;
    return $text;
}

MAIN: {
    my $cgi_object = CGI->new();

    # parse path_info to get object id
    my ($id) = ( split '/', $cgi_object->path_info(), 3 )[1];

    # redirect if trailing slash is missing
    my $url = $cgi_object->url(-path_info => 1);
    if (!$id && $url !~ m{/$}) {
        print $cgi_object->redirect("$url/");
        exit;
    }

    # format paramter determines content type
    my $format = $cgi_object->param('format') || 'html';
    print $cgi_object->header($format eq 'html' ? 'text/html' : 'text/plain');

    # build & display selected view
    view_judge $cgi_object, $format, $id;

    exit;
}
