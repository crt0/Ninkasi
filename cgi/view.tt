#!/usr/bin/perl -T

use strict;
use warnings;

use lib '[% install_base %]/lib/perl5';

use File::Spec;
use Taint::Util;

BEGIN {
    if ( exists $ENV{NINKASI_TEST_SERVER_ROOT} ) {
        my $blib = File::Spec->catfile($ENV{NINKASI_TEST_SERVER_ROOT},
                                       File::Spec->updir(), 'blib');
        untaint $blib;
        require lib;
        lib->import( File::Spec->catfile($blib, 'lib' ),
                     File::Spec->catfile($blib, 'arch') );
    }
}

use Ninkasi::CGI;
use Ninkasi::Config;
use Ninkasi::Constraint;
use Ninkasi::Judge;
use Ninkasi::JudgeSignup;
use Ninkasi::Template;

my %PROCESS = (
    judge => \&view_judge,
    style => \&view_style,
);

# generate a comma-separated list of hyperlinked constraints
sub fetch_constraint_lists {
    my ($judge_id) = @_;

    # fetch constraints for the specified judge
    my $constraint = Ninkasi::Constraint->new();
    my ($sth, $result) = $constraint->bind_hash( {
        bind_values => [$judge_id],
        columns     => [qw/category type/],
        order       => 'category',
        where       => 'judge = ?',
    } );

    # intialize a hash to store the constraint lists (indexed by type name)
    my %constraint = ();

    # build an index of missing rows (we'll remove the categories we find)
    my %not_found  = ();
    @not_found{ 1 .. $#Ninkasi::JudgeSignup::CATEGORIES } = ();

    # walk the rows, building constraint lists
    while ( $sth->fetch() ) {

        # add this category to the appropriate constraint list
        push @{ $constraint{ $Ninkasi::Constraint::NAME{ $result->{type} } } },
             $result->{category};

        # we found a constraint for this category, so delete it from %not_found
        delete $not_found{ $result->{category} };
    }

    # add any missing rows to the 'whatever' list
    @{ $constraint{whatever} }
        = sort { $a <=> $b } keys %not_found, @{ $constraint{whatever} || [] };

    # return a hash of comma-separated, hyperlinked constraint lists
    return {
        map {
            $_ => join ', ', map {
                      qq{<a href="/cgi-bin/view/style/$_">$_</a>}
                  } @{ $constraint{$_} || [] }
        } keys %constraint
    };
}

# display big table of all judges
sub view_all_judges {

    # columns to display
    my @judge_columns = qw/judge_id first_name last_name rank flight1
                           flight2 flight3 competitions_judged
                           pro_brewer/;

    # select whole table & order by last name
    my $judge = Ninkasi::Judge->new();
    my ($sth, $result) = $judge->bind_hash( {
        columns => \@judge_columns,
        order   => 'last_name',
    } );

    # process the template, passing it a function to fetch judge data
    my $template_object = Ninkasi::Template->new();
    $template_object->process( 'view_judges.html', {
        fetch_judge => sub {
            return $sth->fetch() && {
                %$result,
                fetch_constraint_lists
                    => sub { fetch_constraint_lists $result->{judge_id} },
            };
        },
        rank_name => \%Ninkasi::Judge::NAME,
    } ) or warn $template_object->error();

    return;
}

sub view_judge {
    my ($id) = @_;

    return view_all_judges() if !$id;


}

sub view_style {
    my ($category_number) = @_;

    my $category = $Ninkasi::JudgeSignup::CATEGORIES[$category_number - 1];
    my $entry    = $Ninkasi::Constraint::NUMBER{entry};

    my @judge_columns = qw/judge_id first_name last_name rank flight1
                           flight2 flight3 competitions_judged
                           pro_brewer/;
    my @constraint_columns = qw/category judge type/;

    my $judge = Ninkasi::Judge->new();
    my ($sth, $result) = $judge->bind_hash( {
        bind_values => [$category_number, $entry],
        columns     => [@judge_columns, @constraint_columns],
        join        => [qw/Ninkasi::Constraint/],
        order       => 'type DESC, rank DESC, competitions_judged DESC',
        where       => "category = ? AND type != ? AND judge = judge_id",
    } );

    # process the template, passing it a function to fetch judge data
    my $template_object = Ninkasi::Template->new();
    $template_object->process( 'view_judges.html', {
        category        => $category,
        constraint_name => \%Ninkasi::Constraint::NAME,
        fetch_judge     => sub { $sth->fetch() && $result },
        rank_name       => \%Ninkasi::Judge::NAME,
    } ) or warn $template_object->error();

    return;
}

MAIN: {
    my $cgi_object = Ninkasi::CGI->new();

    # parse path_info to determine judge vs. style view (default: judge)
    my ($discard, $type, @arguments) = split '/', $cgi_object->path_info();
    $type ||= 'judge';

    # build & display selected view
    $PROCESS{$type}->(@arguments);

    exit;
}
